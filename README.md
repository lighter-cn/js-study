# JavaScript

## 参考

JavaSrcipt Primer

# 基本文法

## JavaScript とは

### 大文字と小文字を区別する

### 予約語を持つ

予約語 :
開発者がつける識別名として利用できない文字列

### 文はセミコロンで区切る

### strict mode

"use strict"とファイルまたは関数の先頭に書くことで、利用できる
古く安全でない構文や機能が一部禁止されている
Module の実行コンテキストでは strict mode がデフォルト

### 実行コンテキスト : Script と Module

JavaSrcipt の実行コンテキストとして Script と module がある
Script の実行コンテキストでは strict mode はデフォルトではない

## コメント

一行コメント // ...
複数行コメント /＊ ... ＊/

## 変数と宣言

### const

再代入できない変数の宣言とその変数が参照する値を定義できる

const 変数名 = 初期値;

また、const は再代入できない変数を宣言するため、あとから代入することができない

### let

値の再代入可能な変数の宣言

const と異なり初期値を指定せずに定義できる

初期値を指定されない場合、デフォルト値として undefined で初期化される

### var

値の再代入可能な変数を宣言できる

### var の問題点

1. let や const と異なり、同じ名前の変数を再定義できてしまう
2. 変数の巻き上げが発生する

### 変数名に使える名前

1. 半角英数、\_、\$の組み合わせ
2. 数字を変数名の先頭に利用できない
3. 予約語とかぶる名前は利用できない

### const は定数ではない

const はプリミティブな値で初期化した場合、実質的に定数となるが、
プリミティブな値以外は初期化した後も変更できる

## 値の評価と表示

値の評価 :
入力した値を評価してその結果を返すこと
ex) - 1 + 1 の式を評価すると、2 と言う結果を返す - bookTitle という変数を評価すると、変数に代入された値を返す - const x = 1;と言う文を評価することで変数を定義するが、この文に返り値はない

## データ型とリテラル

データ型 :
JavaScript は動的型付け言語であるため、変数の型はないが、
文字列、数値、真偽値といった値の型が存在し、それらの値の型をデータ型と呼ぶ
データ型はプリミティブ型とオブジェクトの二つに大きく分けられる

プリミティブ型 :
真偽値や数値などの基本的な値の型
一度作成したらその値自体を変更できない immutable(不変)の特性を持つ

オブジェクト(複合型) :
複数のプリミティブ型の値、またはオブジェクトからなる集合
一度作成した後もその値自体を変更できる mutable の特性を持つ
また、値そのものではなく、値への山椒を経由して操作されるため参照型のデータとも言える

- プリミティブ型
  - 真偽値(Boolean)
  - 数値(Number)
  - 巨大な整数(Bigint)
  - 文字列(String)
  - undefined
  - null
  - Synbol
- オブジェクト
  - プリミティブ型以外のデータ
  - オブジェクト、配列、関数、正規表現、Date など

typeof 演算子を使うことで、データ型を調べることができる
typeof 演算子ではプリミティブ型またはオブジェクトかを判別するものであって
オブジェクトの詳細は何定できない
null の type が object となるのは歴史的経緯のある仕様バグ

### リテラル

リテラル :
プログラム上で数値や文字列など、データ型の値を直接記述できる構文として定義されたもの

### 真偽値

true / false のリテラルがあり、それぞれ true と false の値を返す

### 数値

- 整数リテラル
  - 10 進数 : 数字の組み合わせ
  - 2 進数 : 0b の後ろに 0/1 の組み合わせ
  - 8 進数 : 0o の後ろに 0-7 の数字の組み合わせ、または 0 から始まる数値
  - 16 進数 : 0x の後ろに 0-9 と a-f までのアルファベットの組み合わせ
- 浮動小数点リテラル
  - 3.14 のような.を含んだ数値(0 から始まる少数は 0 を省略できる)
  - 2e8 のような指数表現
- Bigint リテラル
  - 数値の後ろに n をつける (ex)
  - Bigint は整数を扱うので、小数点を含めると構文エラーになる

Numeric Separators(ES2021) :
数値リテラルの区切り文字として\_を利用できる
リテラルの先頭や数値の最後に追加することはできない

### 文字列

ダブルクォートとシングルクォート :
js では全く同じ意味
"や'を使いたい時は\でエスケープできる

テンプレートリテラル :
バッククォートで囲んだ範囲を文字列とするリテラル
複数行の文字列をエスケープシーケンスなしに書くことができる
テンプレートリテラル内で\${変数名}と書いて変数の値を埋め込むこともできる

### null リテラル

null 値を返すリテラル
null は値がないことを表現したい時に null 値を代入することで変数を定義し、参照できるようになる

### undefined はリテラルではない

undefined はグローバル変数で、undefined と言う値を持っているだけ
そのためローカル変数に undefined を宣言することもできる(する意味はないが)

これに対し true/false/null などはリテラルであるため同じ名前の変数を定義できない

### オブジェクトリテラル

{}を書くことで新しいオブジェクトを作成する
オブジェクトは作成と同時に中身を定義できる
オブジェクトのキーと値を:で区切ったものを{}の中に書くことで作成と同時に初期化される
key には文字列または Synbol を指定し、値にはプリミティブ型の値からオブジェクトまでなんでも入れられる

プロパティ名 :
オブジェクトが持つキーの名前

オブジェクトが持つキーを参照するには.で繋いで参照する方法とブラケットで参照する方法がある
ドット記法ではプロパティ名が変数と同じく識別子である必要があるため、
識別子として利用できないプロパティ名(数字の文字列など)を参照する場合はブラケット記法を利用する

### 配列リテラル

[]で値をカンマ区切りで囲みその値を持つ Array オブジェクトを作成する
js における配列とは複数の値に順序をつけて格納できるオブジェクトの一種
配列は 0 から始まる index に、対応した値を保持している
配列の要素を取得するには、配列に対して array[index]という構文で指定した index の値を参照できる

### 正規表現リテラル

js は正規表現パターンを/ではさみ、正規表現リテラルとして書くことができる

### プリミティブ型とオブジェクト

ラッパーオブジェクト:
プリミティブ型の値をラップしたようなオブジェクト
new 演算子と対応するコンストラクタ関数を使用してプリミティブ型のラッパーオブジェクトを作成できる

プリミティブ型のデータでも暗黙的な型変換が行われ、プロパティやメソッドを参照できるようになる

## 演算子

よく利用する演算処理を記号などであわしたもの

被演算子(オペランド) :
演算子の対象のこと

二項演算子 :
オペランドを二つとる演算子

単項演算子 :
オペランドを 1 つだけとる演算子

### 二項演算子

プラス演算子(+) : 二つの数値を加算する演算子
文字列連結演算子(+) : 二つの文字列を結合した文字列を返す
マイナス演算子(-) : 二つの数値を減産する演算子。左オペランドから右オペランドを減算した値を返す
乗算演算子(\*) : 二つの数値を乗算する演算子
除算演算子(/) : 二つの数値を除算する演算子。左オペランドを右オペランドで除算した値を返す
剰余算演算子(%) : 二つの数値の余りを求める演算子。左オペランドを右オペランドで除算した余りを返す
べき乗演算子(\*\*)[ES2016] : 二つの数値のべき乗を求める演算子。左オペランドを右オペランドでべき乗した値を返す

### 単項演算子(算術)

単項プラス演算子(+) : オペランドを数値に変換する。
単項マイナス演算子(-) : -の数値を記述する場合、もしくは数値の符号を反転する際に使用。
インクリメント演算子(++) : オペランドの数値を+1 する演算子。オペランドの前におくか後ろに奥かで評価の順番が変わる
デクリメント演算子(--) : オペランドの数値を-1 する演算子。オペランドの前後どちらかに置くことで評価順が変わる

### 比較演算子

オペランド同士の値を比較し、真偽値を返す演算子

厳密等価演算子(===) :
左右のオペランドを比較し、同じ型で同じ値の場合、true を返す
オペランドがどちらもオブジェクトである場合は、参照が同じ場合に true を返す

厳密不等価演算子(!==) :
左右のオペランドを比較し、異なる型または異なる値である場合 true を返す

等価演算子(==) :
二つのオペランドを暗黙的な型変換をしてから比較し、等しいなら true を返す
null と undefined の比較では例外的に利用することがあるが、基本的には使うべきではない

不等価演算子(!=) :
二つのオペランドを暗黙的な型変換をしてから比較し、等しくないなら true を返す
こちらも積極的な使用は控え、厳密不等価演算子を利用することが推奨

大なり演算子(>) :
左オペランドが右オペランドより大きい場合に true を返す

大なりイコール演算子(>=) :
左オペランドが右オペランドより大きいまたは等しい場合、true を返す

小なり演算子(<) :
左オペランドが右オペランドより小さい場合に true を返す

小なりイコール演算子(<=) :
左オペランドが右より小さいか等しいなら true を返す

### ビット演算子

オペランドである数字を符号つき 32 ビット整数として扱う
先頭の最上位ビットは符号を表し、0 の場合は正の値、1 の場合負の値を示す

ビット論理積(&) :
bit ごとの AND 演算をした結果を返す

ビット論理和(|) :
ビットごとの or 演算した結果を返す

ビット排他的論理和(^) :
ビットごとの xor 演算した結果を返す

ビット否定(~) :
オペランドの書くビットを単転した値を返す
-1 を返すメソッドのイディオムとして使われることもある

左シフト演算子(<<) :
数値である num を bit の数だけ左へシフトする。左に溢れた bit は破棄され、0 のビットを右から詰める

右シフト演算子(>>) :
数値である num を bit の数だけ右へシフトする。右に溢れたビットは破棄され、左端のビットのコピーを左から詰める

ゼロ埋め右シフト演算子(>>>) :
num を bit の数だけ右シフトし、右に溢れたビット  を破棄し、0 のビットを左から詰める

### 代入演算子

変数に対して代入をする演算子
また、二項演算子と組み合わせて利用し、演算結果を代入できる
(ex)+=,-=,\*=,%=,<<=,>>=,&=,^=,|=,\*\*=

### 分割代入[ES2015]

配列やオブジェクトの値を複数の変数に同時に代入できる構文

### 論理演算子

真偽値を扱う演算子

AND 演算子(&&) :
左辺の評価結果が true ならば右辺の評価結果を返す
左辺の評価結果が false ならばそのまま左辺の値を返す
左辺が false の場合は右辺が評価されないことに注意
また、AND 演算子は左辺を評価する際に真偽値に暗黙的な型変換を行う

短絡評価 :
値が決まった時点でそれ以上評価しないこと

falsy な値 :
以下の 7 つが該当

- false
- undefined
- null
- 0
- 0n
- NaN
- ""

OR 演算子(||) :
左辺の評価が true の場合、そのまま左辺の値を返し、false であれば右辺の評価結果を返す
AND 同様に短絡評価であり、左辺の評価時は真偽値へと暗黙的な型変換を行う

NOT 演算子(!) :
オペランドの評価結果を反転した真偽値を返す
また、真偽値へと暗黙的な型変換を行う

### Nullish coalescing 演算子[ES2020]

左辺が nullish であるなら右辺の評価結果を返す
nullish とは評価結果が null か undefined となる値

### 三項演算子

条件式を評価した結果が true なら true の時に処理する式の評価結果を返し、
条件式が false の時には false の時に処理する式の評価結果を返す
条件式 ? true の時に処理する式 : false の時に処理する式;

### グループ化演算子

演算子の優先順位を明示できる演算子

### カンマ演算子(,)

,で区切った式を左から順に評価し、最後の式の評価結果を返す

## 暗黙的な型変換

ある処理において、その処理過程で行われる明示的ではない型変換のこと
演算子による演算や関数の処理の過程で行われる

### 等価演算子の暗黙的な型変換

###
